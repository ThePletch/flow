// Generated by CoffeeScript 1.10.0
(function() {
  var Field, FlowPoint, TangentChargePoint, Tracer, constants, doEvery,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Field = (function() {
    Field.timeScalar = 1;

    Field.dampingSpeedThreshold = 1.5;

    Field.dampingFactor = 0.95;

    Field.pointCharge = 20.0;

    Field.flowPerFrame = 0.4;

    Field.radius = {
      tracer: 1
    };

    Field.prototype.flowPoints = [];

    Field.prototype.tracers = [];

    Field.prototype.fieldVectors = [];

    function Field(width1, height1) {
      this.width = width1;
      this.height = height1;
    }

    Field.prototype.addFlowPoint = function(flowPoint) {
      return this.flowPoints.push(flowPoint);
    };

    Field.prototype.flowAtPoint = function(x, y, exclude) {
      var flows;
      if (exclude == null) {
        exclude = [];
      }
      flows = this.flowPoints.exclude(exclude).map(function(flowPoint) {
        return flowPoint.flowOnCoord(x, y);
      });
      return VectorMath.addVectors(flows);
    };

    Field.prototype.fieldAtPoint = function(x, y, exclude) {
      var forces;
      if (exclude == null) {
        exclude = [];
      }
      forces = this.flowPoints.exclude(exclude).map(function(flowPoint) {
        return flowPoint.forceOnCoord(x, y);
      });
      return VectorMath.addVectors(forces);
    };

    Field.prototype.randomCoords = function(width, height) {
      if (width == null) {
        width = this.width;
      }
      if (height == null) {
        height = this.height;
      }
      return [Math.random() * width, Math.random() * height];
    };

    Field.prototype.placeRandomTracer = function() {
      var randX, randY, ref;
      ref = this.randomCoords(), randX = ref[0], randY = ref[1];
      return this.tracers.push(new Tracer(this, randX, randY));
    };

    Field.prototype.tick = function() {
      this.tracers.map(function(tracer) {
        return tracer.tick();
      });
      return this.renderToCanvas('that-canvas');
    };

    Field.prototype.renderToCanvas = function(canvasSelector) {
      var canvas, context;
      canvas = document.getElementById(canvasSelector);
      context = canvas.getContext('2d');
      return this.render(context);
    };

    Field.prototype.render = function(context) {
      context.fillStyle = "white";
      context.fillRect(0, 0, this.width, this.height);
      context.fillStyle = "black";
      this.tracers.map(function(tracer) {
        return tracer.render(context);
      });
      return this.flowPoints.map(function(flowPoint) {
        return flowPoint.render(context);
      });
    };

    return Field;

  })();

  FlowPoint = (function() {
    FlowPoint.framesPerFlowPoint = 2;

    FlowPoint.prototype.radius = 2;

    function FlowPoint(field1, x1, y1, flowAngle) {
      this.field = field1;
      this.x = x1;
      this.y = y1;
      this.flowAngle = flowAngle;
      this.field.addFlowPoint(this);
    }

    FlowPoint.prototype.forceOnCoord = function(x, y) {
      var angle, dx, dy, orthogonality, ref, unitVector;
      if (this.charge() === 0) {
        return [0, 0];
      }
      ref = VectorMath.vectorBetween(this.x, this.y, x, y), dx = ref[0], dy = ref[1];
      angle = VectorMath.angleForVector(dx, dy);
      unitVector = VectorMath.unitVectorForAngle(angle);
      orthogonality = Math.abs(Math.sin(angle - this.flowAngle));
      return VectorMath.scaleVector(unitVector, this.charge() * orthogonality * VectorMath.invSquareMagnitudeBetween(this.x, this.y, x, y));
    };

    FlowPoint.prototype.flowOnCoord = function(x, y) {
      var unitVector;
      if (this.flow() === 0) {
        return [0, 0];
      }
      unitVector = VectorMath.unitVectorForAngle(this.flowAngle);
      return VectorMath.scaleVector(unitVector, this.flow() * VectorMath.invSquareMagnitudeBetween(this.x, this.y, x, y));
    };

    FlowPoint.prototype.charge = function() {
      return 0.05 * Field.pointCharge * FlowPoint.framesPerFlowPoint;
    };

    FlowPoint.prototype.flow = function() {
      return Field.flowPerFrame * FlowPoint.framesPerFlowPoint;
    };

    FlowPoint.prototype.render = function() {};

    return FlowPoint;

  })();

  this.ChargePoint = (function(superClass) {
    extend(ChargePoint, superClass);

    ChargePoint.prototype.radius = 3;

    function ChargePoint(field, x, y) {
      ChargePoint.__super__.constructor.call(this, field, x, y, 0);
    }

    ChargePoint.prototype.forceOnCoord = function(x, y) {
      var unitVector;
      if (this.charge() === 0) {
        return [0, 0];
      }
      unitVector = VectorMath.unitVectorBetween(this.x, this.y, x, y);
      return VectorMath.scaleVector(unitVector, this.charge() * VectorMath.invSquareMagnitudeBetween(this.x, this.y, x, y));
    };

    ChargePoint.prototype.charge = function() {
      return Field.pointCharge;
    };

    ChargePoint.prototype.flow = function() {
      return 0;
    };

    ChargePoint.prototype.render = function(context) {
      context.beginPath();
      context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
      return context.stroke();
    };

    return ChargePoint;

  })(FlowPoint);

  TangentChargePoint = (function(superClass) {
    extend(TangentChargePoint, superClass);

    TangentChargePoint.prototype.radius = 5;

    function TangentChargePoint(field, x, y, clockwise1) {
      this.clockwise = clockwise1 != null ? clockwise1 : true;
      TangentChargePoint.__super__.constructor.call(this, field, x, y);
    }

    TangentChargePoint.prototype.charge = function() {
      return 2 * TangentChargePoint.__super__.charge.call(this);
    };

    TangentChargePoint.prototype.tangentDelta = function() {
      return (this.clockwise ? Math.PI : -Math.PI) / 2;
    };

    TangentChargePoint.prototype.forceOnCoord = function(x, y) {
      var angle, dx, dy, normalAngle, ref, unitVector;
      if (this.charge() === 0) {
        return [0, 0];
      }
      ref = VectorMath.vectorBetween(this.x, this.y, x, y), dx = ref[0], dy = ref[1];
      normalAngle = VectorMath.angleForVector(dx, dy);
      angle = normalAngle + this.tangentDelta();
      unitVector = VectorMath.unitVectorForAngle(angle);
      return VectorMath.scaleVector(unitVector, this.charge() * VectorMath.invSquareMagnitudeBetween(this.x, this.y, x, y));
    };

    return TangentChargePoint;

  })(ChargePoint);

  constants = {
    width: 200,
    height: 200,
    chargePoints: [[100, 25], [25, 100], [100, 100], [175, 100], [100, 175]],
    tangentChargePoints: [[100, 25, true], [25, 100, true], [100, 175, true], [175, 100, true], [100, 100, false]],
    tracers: 10,
    frameDelayMs: 100
  };

  doEvery = function(ms, func) {
    return window.setInterval(func, ms);
  };

  window.onload = function() {
    var i, ref, results;
    window.field = new Field(constants.width, constants.height);
    constants.tangentChargePoints.map(function(coords) {
      var clockwise, x, y;
      x = coords[0], y = coords[1], clockwise = coords[2];
      return field.addFlowPoint(new TangentChargePoint(field, x, y, clockwise));
    });
    constants.chargePoints.map(function(coords) {
      var x, y;
      x = coords[0], y = coords[1];
      return field.addFlowPoint(new ChargePoint(field, x, y));
    });
    (function() {
      results = [];
      for (var i = 0, ref = constants.tracers; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map(function() {
      return field.placeRandomTracer();
    });
    return window.tickInterval = doEvery(constants.frameDelayMs, function() {
      return field.tick();
    });
  };

  Tracer = (function() {
    Tracer.prototype.frameCounter = 0;

    Tracer.prototype.enabled = true;

    function Tracer(field1, x1, y1) {
      this.field = field1;
      this.x = x1;
      this.y = y1;
      this.velocity = [0, 0];
      this.flowPoints = [];
    }

    Tracer.prototype.accelerate = function() {
      var chargeVector, flowVector;
      chargeVector = this.field.fieldAtPoint(this.x, this.y, this.flowPoints);
      flowVector = this.field.flowAtPoint(this.x, this.y, this.flowPoints);
      return this.velocity = VectorMath.addVectors([this.velocity, chargeVector, flowVector]);
    };

    Tracer.prototype.clamp = function() {
      var angle, ref, unitVector, vx, vy, xSquared, ySquared;
      xSquared = Math.pow(this.velocity[0], 2);
      ySquared = Math.pow(this.velocity[1], 2);
      if (Math.sqrt(xSquared + ySquared) > Field.dampingSpeedThreshold) {
        ref = this.velocity, vx = ref[0], vy = ref[1];
        angle = VectorMath.angleForVector(vx, vy);
        unitVector = VectorMath.unitVectorForAngle(angle);
        return this.velocity = VectorMath.scaleVector(unitVector, Field.dampingSpeedThreshold);
      }
    };

    Tracer.prototype.move = function() {
      this.x = this.x + this.velocity[0] * Field.timeScalar;
      return this.y = this.y + this.velocity[1] * Field.timeScalar;
    };

    Tracer.prototype.placeFlowPoint = function() {
      var ref, vx, vy;
      if (this.frameCounter < Tracer.framesPerFlowPoint) {
        this.frameCounter++;
        return;
      }
      this.frameCounter = 0;
      ref = this.velocity, vx = ref[0], vy = ref[1];
      return this.flowPoints.push(new FlowPoint(this.field, this.x, this.y, VectorMath.angleForVector(vx, vy)));
    };

    Tracer.prototype.isOffMap = function() {
      return this.x < 0 || this.x > this.field.width || this.y < 0 || this.y > this.field.height;
    };

    Tracer.prototype.tick = function() {
      if (!this.enabled) {
        return;
      }
      if (this.isOffMap()) {
        this.placeFlowPoint();
        this.remove();
        this.field.placeRandomTracer();
        return;
      }
      this.accelerate();
      this.clamp();
      this.placeFlowPoint();
      return this.move();
    };

    Tracer.prototype.render = function(context) {
      if (this.enabled) {
        context.beginPath();
        context.arc(this.x, this.y, Field.radius.tracer, 0, 2 * Math.PI);
        context.stroke();
      }
      return this.renderFlowPoints(context);
    };

    Tracer.prototype.renderFlowPoints = function(context) {
      if (this.flowPoints.length < 2) {
        return;
      }
      context.beginPath();
      this.flowPoints.slice(1).preduce(this.flowPoints[0], function(prev, next) {
        context.moveTo(prev.x, prev.y);
        context.lineTo(next.x, next.y);
        return next;
      });
      return context.stroke();
    };

    Tracer.prototype.remove = function() {
      return this.enabled = false;
    };

    return Tracer;

  })();

  this.VectorMath = (function() {
    function VectorMath() {}

    VectorMath.addVectors = function(vectors) {
      var baseVector;
      baseVector = [0, 0];
      vectors.map(function(vector) {
        baseVector[0] += vector[0];
        return baseVector[1] += vector[1];
      });
      return baseVector;
    };

    VectorMath.scaleVector = function(vector, scalar) {
      return [vector[0] * scalar, vector[1] * scalar];
    };

    VectorMath.vectorBetween = function(xa, ya, xb, yb) {
      return [xb - xa, yb - ya];
    };

    VectorMath.distanceBetween = function(xa, ya, xb, yb) {
      var dx, dy, ref;
      ref = VectorMath.vectorBetween(xa, ya, xb, yb), dx = ref[0], dy = ref[1];
      return Math.sqrt(dx * dx + dy * dy);
    };

    VectorMath.unitVectorBetween = function(xa, ya, xb, yb) {
      var dx, dy, ref;
      ref = VectorMath.vectorBetween(xa, ya, xb, yb), dx = ref[0], dy = ref[1];
      if (dy === 0 && dx === 0) {
        return [0, 0];
      }
      return VectorMath.unitVectorForAngle(VectorMath.angleForVector(dx, dy));
    };

    VectorMath.unitVectorForAngle = function(theta) {
      return [Math.cos(theta), Math.sin(theta)];
    };

    VectorMath.angleForVector = function(x, y) {
      return Math.atan2(y, x);
    };

    VectorMath.invMagnitudeBetween = function(xa, ya, xb, yb) {
      if (xa === xb && ya === yb) {
        return 0;
      }
      return 1 / VectorMath.distanceBetween(xa, ya, xb, yb);
    };

    VectorMath.invSquareMagnitudeBetween = function(xa, ya, xb, yb) {
      var dx, dy, ref;
      if (xa === xb && ya === yb) {
        return 0;
      }
      ref = VectorMath.vectorBetween(xa, ya, xb, yb), dx = ref[0], dy = ref[1];
      return 1 / (dx * dx + dy * dy);
    };

    return VectorMath;

  })();

  Array.prototype.preduce = function(initial, func) {
    return this.reduce(func, initial);
  };

  Array.prototype.exclude = function(otherArray) {
    return this.filter(function(element) {
      return otherArray.indexOf(element) === -1;
    });
  };

}).call(this);
